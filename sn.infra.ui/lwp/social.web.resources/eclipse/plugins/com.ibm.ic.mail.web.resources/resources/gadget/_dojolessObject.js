/* Copyright IBM Corp. 2010, 2015  All Rights Reserved.              */
var navHandlerVer = 1350900150611; // Milliseconds from Epoch (Can be generated by (new Date()).getTime()) FIXME: Is there a better way to detect _NavigationHandler.js version, probably via OpenSocial API?

window.navHandlerVer = navHandlerVer;

// Class definition / constructor, previously com.ibm.lconn.socialmail.gadget._NavigationHandler
function _NavigationHandlerGadget() {}

//Instance methods

_NavigationHandlerGadget.prototype = {
   gadget: null, // URL of the gadget spec (XML)
   commonContainer: null, // Promise returned to confirm that the CommonContainer is loaded
   notifySite: null, // Gadget site for the badge
   inboxSite: null, // Gadget site for the inbox/mail dropdown
   calendarSite: null, // Gadget site for the calendar dropdown
   messageSite: null, // Gadget site for the lightbox content (mail message or event)
   currentSite: null, // string value field used to know which dropdown must be set as hidden when the lightbox is displayed
   iContainer: null, // the Container object
   messageDialog: null, // Dialog object (lightbox)
   hoverLoaded: null, // map of flags to save the loading state of each gadget site
   debugRpc: null, // debug flag
   headerMenu: null, // map of the IDs of the dropdown divs provided by the container, which, in case of Connections, display the loading spinner and the black border.
   focusedElement: null, // when the mail/calendar dropdown is opened, the focus is automatically set to the first anchor. So we save here the DOM element previously focused. In case the user move again the mouse outside, the dropdown hides and the focus is restored to the previous element.
   bootedState: {badge : false, inbox : false, calendar : false, document : false}, // map of flags used to make bootstrap callbacks (when a gadget site is loaded)
   bootstrapCallbacks: {badge : [], inbox : [], calendar : [], document : []}, // map of bootstrap callbacks for each gadget site
   gadgetReady: {badge : false, inbox : false, calendar : false, document : false}, // map fo flags used to keep track of when gadgets sites are ready to process rcp messages
   gadgetReadyCallbacks: {badge : [], inbox : [], calendar : [], document : []}, // map of gadget ready callbacks for each gadget site
   // SM Defect 28978: Date Picker table appears inside the Calendar Dropdown menu even if the dropdown is too small
   calMinHeight: 400, // minimum height of the calendar (transparent div): calendar view header height + date picker header height + month picker height
   refreshCache: 14400, // RequestParameter for cache control setting in the Response Headers. Cache-Control: private,max-age=14400
   gadgetIDs: null, // Object which maps all the gadget site IDs (populated at the beginning)

   // generic functions
   
   setCalendarDisplay: function (el, disp) {
      // TODO: Temporary Workaround for Defect 31515 (IE8 specific) - it could be avoided only if the table element is removed by the calendar view (DWA code). 
      if (el && el.firstChild && el.firstChild.id) {
         var frameCalendar = window.frames[el.firstChild.id];
         if (frameCalendar && frameCalendar.document.getElementsByTagName('table').length > 0)
            frameCalendar.document.getElementsByTagName('table')[0].style.display = disp;
      }
   },

   getSiteFromArea: function (/*osapi.container.Container*/ cc, /*String*/ area){
      // summary:
      //    Returns the site object for the given Social PIM feature area.
      // cc: osapi.container.Container
      //    The Container instance.
      // area: String
      //    The Social PIM feature area.

      return cc.getSiteById(this.gadgetIDs[area]);
   },

   addBootstrapCallback: function (/*String*/ area, /*Function*/ callback){
      // summary:
      //    Adds a callback function when the given Social PIM feature area has been initialized.
      //    If the given feature area has been initialized already at the time when this function is called, call the callback function right away.
      // area: String
      //    The Social PIM feature area.
      // callback: Function
      //    The callback function.

      this.bootstrapCallbacks[area].push(callback);
      this.runBootstrapCallbacks(area);
   },

   runBootstrapCallbacks: function (/*String*/ area){
      // summary:
      //    Run callback functions as the given feature area has been initialized.
      // area: String
      //    The Social PIM feature area.

      if (!this.bootedState[area])
         return;
      for (var callback = null; callback = this.bootstrapCallbacks[area].shift();)
         callback();
   },

   handleIntermediateBootstrap: function (/*osapi.container.Container*/ cc, /*Object*/ data) {
      // summary:
      //    Set up the given Social PIM feature area to tell it when mail badge gadget has been initialized.
      // cc: osapi.container.Container
      //    The Container instance.
      // data: Object
      //    The OpenSocial RPC data.

      if (data.dataObject == "inbox" || data.dataObject == "calendar") {
         var site = this.getSiteFromArea(cc, data.dataObject);
         this.addBootstrapCallback("badge", cre$.util.hitch(this, function() {
             this.addGadgetReadyCallback(data.dataObject, cre$.util.hitch(this, function() {
                 this.hoverLoaded[data.dataObject] = "ready";
                 if (this.headerMenu[data.dataObject]) {
                    // Don't complete bootstrap of gadget unless menu dropdown has been loaded.
                    // If menu dropdown hasn't been loaded, then the gadget has been preloaded, and
                    // gadget bootstrap will be completed when the menu dropdowns get loaded in
                    // response to user action (see navigateInbox and navigateCalendar)
                    if (this.debugRpc)
                       console.log("com.ibm.socpim.rpc.bootstrap - badge - " + site.getId());
                    site.rpcCall("com.ibm.socpim.rpc.bootstrap", "", "badge");
                 }
             }));
         }));
       }
   },

   handleBootstrap: function (/*osapi.container.Container*/ cc, /*Object*/ data) {
      // summary:
      //    Mark that the given Social PIM feature area has been initialized, and run the callbacks as such.
      // data: Object
      //    The OpenSocial RPC data.

      this.bootedState[data.dataObject] = true;
      this.runBootstrapCallbacks(data.dataObject);
   },

   handleGadgetReady: function(/*String*/ area) {
      // summary:
      //    Mark that the given gadget site area that is ready, and run the callbacks as such.
      // gadget: String
      //    the id of the gadget that is ready
      this.gadgetReady[area] = true;
      this.runGadgetReadyCallbacks(area);
   },

   addGadgetReadyCallback: function(/*String*/ area, /*Function*/ callback){
      // summary:
      //    Adds a callback function when the given gadget is ready to accept rpc calls.
      //    If the given gadget is already ready at the time when this function is called, call the callback function right away.
      // area: String
      //    The gadget area.
      // callback: Function
      //    The callback function.

      this.gadgetReadyCallbacks[area].push(callback);
      this.runGadgetReadyCallbacks(area);
   },

   runGadgetReadyCallbacks: function(/*String*/ area){
      // summary:
      //    Run callback functions as the given gadget is ready to accept rpc calls.
      // area: String
      //    The gadget area.
      if (!this.gadgetReady[area]) {
          return;
      }
      for (var callback = null; callback = this.gadgetReadyCallbacks[area].shift();)
         callback();
   },

   registerGadgetReadyHandler: function(/*osapi.container.Container*/ cc, /*String*/ area, registrationSiteId) {
       // summary:
	   //    Register a life cycle callback handler so that we will know when the gadget is ready to 
	   //    accept rpc calls (after the onRender life cycle event).  The callback handler is removed
	   //    once it fires for the specified site id.
	   // cc: osapi.container.Container
	   //    the container instance
	   // registrationSiteId: String
	   //    the site id of the gadget being registered
       var handlerName = "com.ibm.socpim.navigateGadget_" + area;
       cc.addGadgetLifecycleCallback(handlerName, {onRender: cre$.util.hitch(this, function(gadgetUrl, siteId) {
           if (siteId === registrationSiteId) {
               cc.removeGadgetLifecycleCallback(handlerName);
               this.handleGadgetReady(area);
           }
       })});
   },

   registerGadgetVisibilityController: function (/*osapi.container.Container*/ cc, /*String*/ registrationSiteId) {
       // summary:
	   //    Register a life cycle callback handler so that we will know when the gadget iframe has rendered
	   //    so that we can show the iframe content.  We need to do this instead of waiting for the gadget
	   //    to show itself for those cases when the gadget failed to load and the iframe contains
	   //    and error page that needs to be displayed.  The callback handler is removed
	   //    once it fires for the specified site id.
	   // cc: osapi.container.Container
	   //    the container instance
	   // registrationSiteId: String
	   //    the site id of the gadget being registered
       var handlerName = registrationSiteId + "_visibilityController";
       cc.addGadgetLifecycleCallback(handlerName, {onRender: cre$.util.hitch(this, function(gadgetUrl, siteId) {
           if (siteId === registrationSiteId) {
               cc.removeGadgetLifecycleCallback(handlerName);
               this.showSiteContent(registrationSiteId);
           }
       })});
  },
   
   setOffsetPos: function (/*osapi.container.Container*/ cc, /*Object*/ pane,
      /*String*/ type, /*String*/ site, /*String*/ channel){
      // cc: osapi.container.Container
      //    The Container instance.
      // pane: the gadget site
      //    inboxSite or calendarSite
      // type: String
      //    inbox or calendar
      // site: String
      //    os-site-mail-hover or os-site-calendar-hover
      // channel: String
      //    com.ibm.socpim.mailoffsetpos or com.ibm.socpim.calendaroffsetpos

      if (!pane || !this.hoverLoaded || this.hoverLoaded[type] !== "loaded" || typeof pane._offsetTop == "undefined")
         return;

      cc.getSiteById(site).rpcCall('com.ibm.socpim.rpc', '', {
         type: channel, dataObject: {top: pane._offsetTop}
      });
   },

   setBorderExtents: function (/*osapi.container.Container*/ cc, /*Object*/ pane,
      /*String*/ type, /*String*/ site, /*String*/ channel){
      // cc: osapi.container.Container
      //    The Container instance.
      // pane: the gadget site
      //    inboxSite or calendarSite
      // type: String
      //    inbox or calendar
      // site: String
      //    os-site-mail-hover or os-site-calendar-hover
      // channel: String
      //    com.ibm.socpim.mailoffsetpos or com.ibm.socpim.calendaroffsetpos

      if (!pane || !this.hoverLoaded || this.hoverLoaded[type] !== 'loaded' || typeof pane._borderWidth == "undefined")
         return;

      cc.getSiteById(site).rpcCall('com.ibm.socpim.rpc', '', {
         type: channel, dataObject: {b: pane._borderWidth}
      });
   },
   
   createElementForEEHandler: function (rel, opt_gadgetInfo, opt_viewTarget, opt_coordinates, parentSite) {
       if (opt_viewTarget == 'container/mail/preview/ee' && parentSite.getId() == this.gadgetIDs.message) {
           var parentSiteElem = document.getElementById(parentSite.getId()),
               parent = parentSiteElem.parentElement,
               elem = document.getElementById(this.gadgetIDs.message),
               eeElem = document.getElementById(this.gadgetIDs.messageEE);

           var oSite = parentSite.container_.getSiteById(this.gadgetIDs.messageEE);
           if (oSite)
              parentSite.container_.closeGadget(oSite);

           elem.style.height = 'auto';
           eeElem.style.display = 'block';
           
           var computedStyleElement;
           if (document.defaultView && document.defaultView.getComputedStyle)
              computedStyleElement = document.defaultView.getComputedStyle(parentSiteElem);    
           else // IE8
              computedStyleElement = parentSiteElem.currentStyle;
           
           
           var pTop = parentSiteElem.offsetHeight + 
                      parseFloat(computedStyleElement.marginTop === 'auto' ? '0px' : computedStyleElement.marginTop) + 
                      parseFloat(computedStyleElement.marginBottom === 'auto' ? '0px' : computedStyleElement.marginBottom);
           eeElem.style.marginTop = pTop + 'px';

           // Defect 37615, 47444: workaround for box-model padding issue.
           // The height will need to be adjusted to subtract the height of the mail site on top.
           var h = Math.abs(parent.offsetHeight - pTop) + 'px';
           eeElem.style.height = h;

           return eeElem;
       }
   },

   destroyElementForEEHandler: function (site) {
       var id = site.getId(),
       elem = document.getElementById(this.gadgetIDs.message),
       eeElem = document.getElementById(this.gadgetIDs.messageEE);

       // The dialog closing should call destroy on the site it contains
       // If it does that, this should clean up the EE if it's also there.
       if (id == this.gadgetIDs.message) {
           var oSite = site.container_.getSiteById(this.gadgetIDs.messageEE);
           if (oSite) {
              site.container_.closeGadget(oSite);
         }
      } else if (id == this.gadgetIDs.messageEE){
         elem.style.height = '';
         eeElem.style.display = '';
       }

       site.container_.closeGadget(site); // this is a must.
       // if this is an EE closing (id == os-site-mail-hover-preview-message-ee or not defined and siteid = os-site-mail-hover-preview-message-ee )
       // then we might also want to close the dialog instead of reverting to the html display of the email.
       // gadgets can close themselves... the ee is trying to close itself when id is not defined and siteid = os-site-mail-hover-preview-message-ee
   },

   saveFocusedElement: function (args) {
      // called when mail/calendar DD are shown (onmouseover) and inner elements gets the focus
      if (args && args[0] === 'mouseover') {
         this.focusedElement = document.activeElement;
      }
   },

   restoreFocusedElement: function () {
      // called when mail/calendar popup gets hidden, at this stage the element of the page previously focused gets the focus again
      if (this.focusedElement) {
         this.focusedElement.focus();
      }
      this.focusedElement = undefined;
   }, 
   
   
   // called at first
   
   initialization: function () {
      if (!this.commonContainer) {  // Initialized only once
         
         if (this.isDebug){
            console.log('Initializing container');
         }

         // verify we're not using it directly, some fields/methods are expected (see for example NavigationHandlerCore.js)
         if (!this.verifyExpectedData()) {
            return false;
         }
         
         // method which generate dynamically the suffix used for the gadget sites
         this.generateSuffixToSiteIdsOnHeader();
         
         // DOM manipulation with the generated suffix "dynamicSiteIdSuffix" (see header.jsp)
         if (!this.addSuffixToSiteIdsOnHeader()) {
            return false;
         }
         
         // hide the badge first for defect 65294
         var badgeSpan = document.getElementById(this.gadgetIDs.badge);
         badgeSpan.style.visibility = 'hidden';
         
         this.iContainer = this.initContainer();
         this.commonContainer = this.iContainer.getCommonContainer();

         var serviceUrl = null;

         this.hoverLoaded = {
               inbox: false,
               calendar: false,
               badgeNotified: false
            };
         this.debugRpc = (location.search.match(/[&\?]debugRpc=([^&]*)/i) || [])[1] in {"true": 1, 1: 1};
         this.headerMenu = {
               inbox: null,
               calendar: null
         };

         serviceUrl = this.getServiceUrl();
         if (serviceUrl) {
            serviceUrl = serviceUrl.toString();
            // if only Connections Mail service context specified in LCC.xml then append location of gadget specification
            if (serviceUrl.search(/inbox\.xml/) === -1)
               serviceUrl = serviceUrl + "/gadgets/inbox.xml";
         }
         this.gadget = serviceUrl;
         
         // 76519: disabling until a config flag is available to load an arbitrary gadget
         // get gadget from URL in debug mode
         var gadgetParam = this.getUrlParameter(window.location.href, 'gadget');
         if (this.isDebug && gadgetParam && gadgetParam!="") {
            this.gadget = window.location.protocol +"//"+ gadgetParam;
         }
         
         // function "checkInitialized" checks if cre$ objects is available
         var checkInitialized = function(self) {
            if (typeof(cre$) === 'undefined') {
               setTimeout(function(){checkInitialized(self);}, 50);
            }
            else {
               self.addLoginLogoutHandlers();
               
               self.iContainer.views.registerCreateElementForEEHandler(
                     'container/mail/preview/ee', 
                     cre$.util.hitch(self, self.createElementForEEHandler), 
                     cre$.util.hitch(self, self.destroyElementForEEHandler)
               );         

               self.commonContainer.then(function(cc) {
                   // TODO This override function should be removed when JIRA SHINDIG-1766 is accepted.
                   osapi.container.GadgetHolder.prototype.createIframeAttributeMap = function(url, overrides) {
                       if (this.el_.id == self.gadgetIDs.messageEE) {
                           // The EE site here will not grow with dynamic height, so we tell the iframe to scroll if the content won't fit.
                           overrides = overrides || {};
                           overrides['scrolling'] = 'auto';
                       }
                       return osapi.container.SiteHolder.prototype.createIframeAttributeMap.call(this, url, overrides);
                   };
                  
                  cc.preloadGadget(self.gadget, function() {
                      if (self.iContainer && self.iContainer.ICactions) {
                        self.iContainer.ICactions.registerNavigateGadgetHandler(cre$.util.hitch(self, self.navigateGadgetHandler));
                     } else {
                        // note, this is unsafe for a gadget todo
                        cc.actions.registerNavigateGadgetHandler(cre$.util.hitch(self, self.navigateGadgetHandler));
                     }

                     // Navigate the notifications gadget view
                     var params = {};
                     var renderParam = osapi.container.RenderParam;
                     // need to set height = 0 in IE
                     params[renderParam.WIDTH] = "15px";
                     params[renderParam.HEIGHT] = self.isIE() ? "0px" : "15px";
                     params[renderParam.REFRESH] = self.refreshCache;
                     params[renderParam.USER_PREFS] = self.getUserPrefs();
                     var viewParams = {
                           gadgetId: self.gadgetIDs.badge,
                           dynamicSiteIdSuffix: self.dynamicSiteIdSuffix,
                           currentUserId: self.getUserId()
                     };
                     if (!self.notifySite) {
                        self.notifySite = cc.newGadgetSite(document.getElementById(self.gadgetIDs.badge));
                     }

                     self.registerGadgetReadyHandler(cc, 'badge', self.notifySite.getId());
                     cc.navigateGadget(self.notifySite, self.gadget, viewParams, params);
                     
                     self.iContainer.loadWidget({
                        definitionUrl: self.gadget,
                        placement: self.gadgetIDs.inbox,
                        componentType: 'gadget'
                     });
                     self.setBadgeAccessibilityAttributes();
                  });
                  
                  // add action listeners
                  cc.actions.addListener(cre$.util.hitch(self, self.onMessageOpen), 'com.ibm.socpim.openDocument');
                  cc.actions.addListener(cre$.util.hitch(self, self.onMessageCompose), 'com.ibm.socpim.mail.messageCompose');
                  cc.actions.addListener(cre$.util.hitch(self, self.onMessageClose), 'com.ibm.socpim.closeDocument.sm');
                  // conflict with "com.ibm.socpim.closeDocument" in "\osactions\DocumentActionDispatcher.js": renamed adding "sm" in the end
                  
                  self.addBootstrapCallback("badge", function() {
                      // After the badge gadget is booted, preload the remaining gadgets.  We do this 
                      // both to minimize the timing window for gadget load failures due to session
                      // timeout, as well as to improve responsiveness of the gadgets to first hover.
                      setTimeout(function() {self.navigateInbox();}, 100);
                      setTimeout(function() {self.navigateCalendar();}, 150);
                      setTimeout(function() {self.navigateOpenMessage(self.gadget, "Document");}, 200);
                  });
                  
                  self.startupSettings();

                  // We could do this only once, so then should manage data passing through this channel in centralised way
                  cc.rpcRegister('com.ibm.socpim.rpc', function(rpcArgs, rpcData) {
                     self.debugRpc && window.console && console.log("com.ibm.socpim.rpc received: " + rpcData.type + ": " + (typeof rpcData.dataObject == "object" && (window.JSON || {}).stringify ? JSON.stringify(rpcData.dataObject) : rpcData.dataObject));
                     
                     if (rpcData.type == "com.ibm.socpim.bootstrap.beingloaded") {
                        self.handleIntermediateBootstrap(cc, rpcData);
                     }
                     else if (rpcData.type == "com.ibm.socpim.bootstrap.loaded") {
                        
                        self.handleBootstrap(cc, rpcData);
                        self.verifyVisibility(rpcData.dataObject);
                        if (rpcData.dataObject == "inbox")
                           self.hoverLoaded.inbox = "loaded";
                        else if (rpcData.dataObject == "calendar")
                           self.hoverLoaded.calendar = "loaded";
                        else if (rpcData.dataObject == "badge") {
                            // set the badge to be visible for now, for defect 65294
                            var badgeSpan = document.getElementById(self.gadgetIDs.badge);
                            badgeSpan.style.visibility = '';
                        }
                        else if (rpcData.dataObject == "document")
                            self.messageSite.loaded = true;
                        
                        // Update window size via rpc service
                        var win = document.parentWindow || document.defaultView;
                        self.commonContainer.then(function(cc) {
                           if (rpcData.dataObject == "inbox" || rpcData.dataObject == "calendar") {
                              var siteToSendTo = (rpcData.dataObject == "inbox") ? self.gadgetIDs.inbox : self.gadgetIDs.calendar;
                              
                              var smResizeListener = function() {
                                 cc.getSiteById(siteToSendTo).rpcCall('com.ibm.socpim.rpc', '', {type: "com.ibm.socpim.windowgeom", dataObject: {w: document.documentElement.clientWidth || document.getElementsByTagName('body')[0].clientWidth || win.innerWidth, h: document.documentElement.clientHeight || document.getElementsByTagName('body')[0].clientHeight || win.innerHeight}});
                              };
                              smResizeListener();
                              if(window.addEventListener) {
                                 window.addEventListener("resize", smResizeListener);
                              } else if (window.attachEvent) { // IE8
                                 window.attachEvent("onresize", smResizeListener);
                              }
                           }
                        });
                        if (self.inboxSite) {
                           self.setOffsetPos(cc, self.inboxSite, "inbox", self.gadgetIDs.inbox, "com.ibm.socpim.mailoffsetpos");
                           self.setBorderExtents(cc, self.inboxSite, "inbox", self.gadgetIDs.inbox, "com.ibm.socpim.mailborderextents");
                        }
                        if (self.calendarSite) {
                           self.setOffsetPos(cc, self.calendarSite, "calendar", self.gadgetIDs.calendar, "com.ibm.socpim.calendaroffsetpos");
                           self.setBorderExtents(cc, self.calendarSite, "calendar", self.gadgetIDs.calendar, "com.ibm.socpim.calendarborderextents");
                        }
                     }
                     else if (rpcData.type == "com.ibm.socpim.calendar.datepicker.visibility") {
                        self.calendarSite._datepick = rpcData.dataObject == "visible";
                        if (self.calendarSite._currentHeight) {
                           self.calendarSite.domNode.style.height = self.calendarSite.domNode.firstChild.style.height = Math.max(rpcData.dataObject == "visible" ? self.calMinHeight : 0, self.calendarSite._currentHeight)+ "px";
                        }
                     }
                     
                     // extra RPC calls callbacks which may include container-specific js/DOM references (ie. gadgetSiteObject.onClose)
                     self.extraRpcCalls(rpcData);
                  });
               });
            }
         };
         // call function "checkInitialized" to check if cre$ objects is available
         checkInitialized(this);
      }
   },
   
   navigateGadgetHandler: function (gadgetUrl, opt_params) {
      if (this.gadget === gadgetUrl) {
         
         this.navigateGadgetHandlerCustomProperties();

         var optParam = osapi.container.actions.OptParam;
         var view = opt_params[optParam.VIEW];
         var target = opt_params[optParam.VIEW_TARGET];
         if (target == 'container/mail/preview') {
            this.navigateOpenMessage(gadgetUrl, view);
         }
      }
   },
   
   navigateInbox: function (menuItem, event) {
      // if menuItem and event are not specified, then gadget is being preloaded 
      if (!this.notifySite) {
         return;
      }
      if (!this.headerMenu.inbox && menuItem) {
          // Get here in response to user hovering the mail header icon for first time
          this.headerMenu.inbox = this.getDropdownContainerId(menuItem);
          if (this.inboxSite) {
              // inbox site already navigated.  Load the container dropdown and attempt to 
              // complete gadget bootstrap.
              this.loadContainerDropdown(menuItem, event);
              if (this.hoverLoaded.inbox === "ready") {
                  // complete gadget bootstrap
                  this.commonContainer.then(cre$.util.hitch(this, function(cc) {
                      if (this.debugRpc)
                          console.log("com.ibm.socpim.rpc.bootstrap - badge - sending to " + this.inboxSite.site.getId());
                      cc.getSiteById(this.inboxSite.site.getId()).rpcCall("com.ibm.socpim.rpc.bootstrap", "", "badge");
                  }));
              }
          }
      }
      if (!this.inboxSite) {
         this.commonContainer.then(cre$.util.hitch(this, function(cc) {
            this.inboxSite = this.generateGadgetSite({
               id: this.gadgetIDs.inbox,
               bindto: this.idMailLoadingSpinner,
               'class': this.classMailDropdown,
               hide: cre$.util.hitch(this, function() {
                  this.inboxSite.domNode.style.visibility = 'hidden';
                  this.inboxSite.domNode.style.zIndex = -1;
                  var rpcData = {type: 'com.ibm.socpim.MailDropDown', dataObject: 'hidden'};
                  
                  if (this.debugRpc)
                     console.log("com.ibm.socpim.rpc sending " + rpcData.type + ": " + rpcData.dataObject + " to os-site-mail-notify");
                  cc.getSiteById(this.gadgetIDs.badge).rpcCall('com.ibm.socpim.rpc', '', rpcData);
                  var checkLoaded = function(self) {
                     if (self.hoverLoaded.inbox !== "loaded") {
                        setTimeout(function(){checkLoaded(self);}, 10);
                     }
                     else {
                        if (self.debugRpc)
                           console.log("com.ibm.socpim.rpc sending " + rpcData.type + ": " + rpcData.dataObject + " to os-site-mail-hover");
                        cc.getSiteById(self.gadgetIDs.inbox).rpcCall('com.ibm.socpim.rpc', '', rpcData);
                     }
                  };
                  checkLoaded(this);
                  
                  this.restoreFocusedElement();
               }),
               show: cre$.util.hitch(this, function() {
                  
                  this.saveFocusedElement(arguments[0]);
                  
                  // SM Defect 36265: Mail dropdown pops up unexpectedly -- any time mouse pointer goes near where the Load More Messages link would be.
                  // Added "zIndex: 2000"
                  // TODO: Use a CSS class instead so that "2000" can be removed
                  this.inboxSite.domNode.style.visibility = 'visible';
                  this.inboxSite.domNode.style.zIndex = 2000;
   
                  if (typeof this.inboxSite._currentHeight != "undefined") {
                     // In case com.ibm.socpim.bootstrap.loaded is called before the show() is called,
                     // try setting the drop-down height value again here.
                     this.setDropDownHeight(this.inboxSite, this.inboxSite._currentHeight, "inbox");
                  }
                  // Get the inboxSite.domNode.offsetTop, previously done with dojo.marginBox(headerMenu.inbox).h etc
                  // when this widget is being displayed.
                  if (typeof this.inboxSite._offsetTop == "undefined") {
                     this.inboxSite._offsetTop = this.inboxSite.domNode.offsetTop;
                     this.setOffsetPos(cc, this.inboxSite, "inbox", this.gadgetIDs.inbox, "com.ibm.socpim.mailoffsetpos");
                  }
                  if (typeof this.inboxSite._borderWidth == "undefined") {
                     var headerMenuMail = document.getElementById(this.headerMenu.inbox);
                     if (headerMenuMail) {

                        this.inboxSite._borderWidth = this.calculateBorderWidth(headerMenuMail);
                        this.setBorderExtents(cc, this.inboxSite, "inbox", this.gadgetIDs.inbox, "com.ibm.socpim.mailborderextents");
                     }
                  }
   
                  var rpcData = {type: 'com.ibm.socpim.MailDropDown', dataObject: 'visible'};
   
                  if (this.debugRpc)
                     console.log("com.ibm.socpim.rpc sending " + rpcData.type + ": " + rpcData.dataObject + " to os-site-mail-notify");
   
                  cc.getSiteById(this.gadgetIDs.badge).rpcCall('com.ibm.socpim.rpc', '', rpcData);
                  var checkLoaded = function(self) {
                     if (self.hoverLoaded.inbox !== "loaded") {
                         setTimeout(function(){checkLoaded(self);}, 10);
                     }
                     else {
                        if (self.debugRpc)
                           console.log("com.ibm.socpim.rpc sending " + rpcData.type + ": " + rpcData.dataObject + " to os-site-mail-hover");
   
                        cc.getSiteById(self.gadgetIDs.inbox).rpcCall('com.ibm.socpim.rpc', '', rpcData);
                        /* compatibility ICM 1.0 FP1 (10-oct-12) - START */
                        if (!self.hoverLoaded.badgeNotified) {
                           if (self.debugRpc)
                              console.log("com.ibm.socpim.rpc.bootstrap sending to os-site-mail-notify");
   
                           cc.getSiteById(self.gadgetIDs.badge).rpcCall('com.ibm.socpim.rpc.bootstrap', '', null);
                           self.hoverLoaded.badgeNotified = true;
                        }
                        
                        if (!self.hoverLoaded.messagesNotified && !!cc.getSiteById(self.gadgetIDs.message)) {
                           if (self.debugRpc)
                              console.log("com.ibm.socpim.rpc.bootstrap sending to os-site-mail-hover-preview-messages");
                           
                           cc.getSiteById(self.gadgetIDs.message).rpcCall('com.ibm.socpim.rpc.bootstrap', '', null);
                           self.hoverLoaded.messagesNotified = true;
                        }
                        /* compatibility ICM 1.0 FP1 (10-oct-12) - END */
                        self.updateWarning(self.inboxSite); //a11y
                        }
                  };
                  checkLoaded(this);
               })
            });
            document.getElementsByTagName('body')[0].appendChild(this.inboxSite.domNode);

            var params = {};
            var renderParam = osapi.container.RenderParam;
            params[renderParam.WIDTH] = '100%';
            params[renderParam.HEIGHT] = '100%';
            params[renderParam.VIEW] = 'HoverView';
            params[renderParam.REFRESH] = this.refreshCache;
            var viewParams = {
                  gadgetId: this.gadgetIDs.inbox,
                  dynamicSiteIdSuffix: this.dynamicSiteIdSuffix,
                  currentUserId: this.getUserId()
            };
            params[renderParam.USER_PREFS] = this.getUserPrefs();
         
            this.inboxSite.site = cc.newGadgetSite(this.inboxSite.domNode);
            var siteId = this.inboxSite.site.getId();
            this.registerGadgetReadyHandler(cc, 'inbox', siteId);
            this.registerGadgetVisibilityController(cc,siteId);
            // This will only ever get navigated to once.
            cc.navigateGadget(this.inboxSite.site, this.gadget, viewParams, params, function() {});
            // Hide <iframe> for gadget until bootstrap code in gadget finishes
            this.hideInboxWhileLoading();
         }))
           .then(cre$.util.hitch(this, function () {
              // If !menuItem, then we're preloading the gadget site and user hasn't hovered 
              // over mail icon yet.  Dropdowns will be loaded later
              if (menuItem) {
                 this.loadContainerDropdown(menuItem, event);
              }
           }));
      }
      this.currentSite = 'mail'; //used on navigateGadgetHandler and onMessageOpen
   },
   
   navigateCalendar: function (menuItem, event) {
      // if menuItem and event are not specified, then gadget is being preloaded 
      if (!this.notifySite) {
         return;
      }
      if (!this.headerMenu.calendar && menuItem) {
          // Get here in response to user hovering the calendar header icon for first time
          this.headerMenu.calendar = this.getDropdownContainerId(menuItem);
          if (this.calendarSite) {
              // Calendar site already navigated.  Load the container dropdown and attempt to 
              // complete gadget bootstrap.
              this.loadContainerDropdown(menuItem, event);
              if (this.hoverLoaded.calendar === "ready") {
                  this.commonContainer.then(cre$.util.hitch(this, function(cc) {
                      // complete gadget bootstrap
                      if (this.debugRpc)
                          console.log("com.ibm.socpim.rpc.bootstrap - badge - sending to " + this.calendarSite.site.getId());
                      cc.getSiteById(this.calendarSite.site.getId()).rpcCall("com.ibm.socpim.rpc.bootstrap", "", "badge");
                  }));
              }
          }
      }
      if (!this.calendarSite) {
         this.commonContainer.then(cre$.util.hitch(this, function(cc) {
            this.calendarSite = this.generateGadgetSite({
               id: this.gadgetIDs.calendar,
               bindto: this.idCalendarLoadingSpinner,
               'class': this.classCalendarDropdown,
               hide: cre$.util.hitch(this, function() {
                  this.calendarSite.domNode.style.visibility = 'hidden';
                  this.calendarSite.domNode.style.zIndex = -1;
                  var rpcData = {type: 'com.ibm.socpim.CalendarDropDown', dataObject: 'hidden'};
                  var checkLoaded = function(self) {
                     if (self.hoverLoaded.calendar !== "loaded") {
                        setTimeout(function(){checkLoaded(self);}, 10);
                     }
                     else {
                        if (self.debugRpc)
                           console.log("com.ibm.socpim.rpc sending " + rpcData.type + ": " + rpcData.dataObject + " to os-site-calendar-hover");
   
                        cc.getSiteById(self.gadgetIDs.calendar).rpcCall('com.ibm.socpim.rpc', '', rpcData);
                     }
                  };
                  checkLoaded(this);
                  this.setCalendarDisplay(this.calendarSite.domNode, 'none');
                  this.restoreFocusedElement();
               }),
               show: cre$.util.hitch(this, function() {
   
                  this.saveFocusedElement(arguments[0]);
                  
                  // FIXME: avoid inline styles
                  this.calendarSite.domNode.style.visibility = 'visible';
                  this.calendarSite.domNode.style.zIndex = 2000;
   
                  if (typeof this.calendarSite._currentHeight != "undefined") {
                     // In case com.ibm.socpim.bootstrap.loaded is called before the show() is called,
                     // try setting the drop-down height value again here.
                     this.setDropDownHeight(this.calendarSite, this.calendarSite._currentHeight, "calendar");
                  }
                  // Get the calendarSite.domNode.offsetTop, previously done with dojo.marginBox(headerMenu.calendar).h etc
                  // when this widget is being displayed
                  if (typeof this.calendarSite._offsetTop == "undefined") {
                     this.calendarSite._offsetTop = this.calendarSite.domNode.offsetTop;
                     this.setOffsetPos(cc, this.calendarSite, "calendar", this.gadgetIDs.calendar, "com.ibm.socpim.calendaroffsetpos");
                  }
                  if (typeof this.calendarSite._borderWidth == "undefined") {
                     var headerMenuCalendar = document.getElementById(this.headerMenu.calendar);
                     if (headerMenuCalendar) {
                        this.calendarSite._borderWidth = this.calculateBorderWidth(headerMenuCalendar);
                        this.setBorderExtents(cc, this.calendarSite, "calendar", this.gadgetIDs.calendar, "com.ibm.socpim.calendarborderextents");
                     }
                  }
   
                  var rpcData = {type: 'com.ibm.socpim.CalendarDropDown', dataObject: 'visible'};
                  var checkLoaded = function(self) {
                        if (self.hoverLoaded.calendar !== "loaded") {
                            setTimeout(function(){checkLoaded(self);}, 10);
                        }
                        else {
                           if (self.debugRpc)
                              console.log("com.ibm.socpim.rpc sending " + rpcData.type + ": " + rpcData.dataObject + " to os-site-calendar-hover");
                           
                           cc.getSiteById(self.gadgetIDs.calendar).rpcCall('com.ibm.socpim.rpc', '', rpcData);
                           self.updateWarning(self.calendarSite); //a11y
                        }
                  };
                  checkLoaded(this);
                  this.setCalendarDisplay(this.calendarSite.domNode, 'table');
               })
            });
            document.getElementsByTagName('body')[0].appendChild(this.calendarSite.domNode);
   
            var params = {};
            var renderParam = osapi.container.RenderParam;
            params[renderParam.WIDTH] = '100%';
            params[renderParam.HEIGHT] = '100%';
            params[renderParam.VIEW] = 'CalendarHoverView';
            params[renderParam.REFRESH] = this.refreshCache;
            var viewParams = {
                  gadgetId: this.gadgetIDs.calendar,
                  dynamicSiteIdSuffix: this.dynamicSiteIdSuffix,
                  currentUserId: this.getUserId()
            };
            params[renderParam.USER_PREFS] = this.getUserPrefs();
   
            this.calendarSite.site = cc.newGadgetSite(this.calendarSite.domNode);
            var siteId = this.calendarSite.site.getId();
            this.registerGadgetReadyHandler(cc, 'calendar', siteId);
            this.registerGadgetVisibilityController(cc,siteId);
            // This will only ever get navigated to once.
            cc.navigateGadget(this.calendarSite.site, this.gadget, viewParams, params, function() {});
            // Hide <iframe> for gadget until bootstrap code in gadget finishes
            this.hideCalendarWhileLoading();
         }))
         .then(cre$.util.hitch(this, function () {
          if (menuItem) {
              // If !menuItem, then we're preloading the gadget site and user hasn't hovered 
              // over mail icon yet.  Dropdowns will be loaded later.
              this.loadContainerDropdown(menuItem, event);
           }
         }));
      }
      this.currentSite = 'calendar'; // used on navigateGadgetHandler and onMessageOpen
   },
   
   navigateOpenMessage: function (gadgetUrl, view) {
      
      this.closeCurrentSite(); // close the dropdown, it's required here even if it's called also in "onMessageOpen". Otherwise the first time the lightbox is opened, the dropdown stays in overlay
      
      if (!this.messageDialog) {
         if (!this.messageSite) {
            this.generateMessageSite();
         }
   
         this.generateMessageDialog();
   
         this.commonContainer.then(cre$.util.hitch(this, function(cc) {
            var params = {};
            var renderParam = osapi.container.RenderParam;
            params[renderParam.WIDTH] = '100%';
            params[renderParam.HEIGHT] = '100%';
            params[renderParam.VIEW] = view;
            params[renderParam.REFRESH] = this.refreshCache;
            var viewParams = {
               gadgetId: this.gadgetIDs.message,
               dynamicSiteIdSuffix: this.dynamicSiteIdSuffix,
               currentUserId: this.getUserId()
            };
            params[renderParam.USER_PREFS] = this.getUserPrefs();
   
            var siteNode = document.getElementById(this.gadgetIDs.message);
            this.messageSite.site = cc.newGadgetSite(siteNode);
            var siteId = this.messageSite.site.getId();
            this.registerGadgetReadyHandler(cc, 'document', siteId);
            this.registerGadgetVisibilityController(cc,siteId);
            cc.navigateGadget(this.messageSite.site, gadgetUrl, viewParams, params, function() {});
            // Hide <iframe> for gadget until bootstrap code in gadget finishes
            this.hideLightboxWhileLoading();
         }));
         // In order for the high-contrast mode initialization to successfully complete,
         // the dialog must not be display:none, so instead we set the visibility to hidden
         // to keep the dialog from showing.  We'll reset the visibility to normal the first
         // time the dialog is shown (see onMessageOpen).
         this.messageDialog.domNode.style.visibility = "hidden";
         this.messageDialog.domNode.style.display = "block";
      }
   },
   
   setDropDownHeight: function (pane, /*Number|arguments*/ height, /*String*/ type) {
      // pane: the gadget site
      //    should be either: inboxSite or calendarSite
      // height: Number
      //    The height of the pane
      // type: String
      //    Should be either: inbox or calendar
   
      if (!pane || !this.headerMenu || !this.headerMenu[type])
         return;
   
      var minHeight = 0;
      if (pane._datepick) { // calendar dropdown with the datePicker/monthPicker opened
         minHeight = this.calMinHeight;
      }
      
      height = height[0] ? height[0] : height;
      // verify it's a number, in case remove the px suffix
      height = parseInt(height, 10);
   
      pane._currentHeight = height;
      var header = document.getElementById(this.headerMenu[type]),
         bindoto = document.getElementById(pane.bindto);
   
      if (!header || !bindoto)
         return;
   
      header.style.height = height + 'px';
      bindoto.style.height = height + 'px';
      var mh = (typeof minHeight != 'undefined' ? Math.max(height, minHeight) : height) + 'px';
      pane.domNode.style.height = mh;
      pane.domNode.firstChild.style.height = mh;
   },
   
   getPane: function (key) {
      return {
         inbox: this.inboxSite,
         calendar: this.calendarSite,
         document: this.messageSite,
         badge: this.notifySite
      }[key];
   },
   
   // handler to close the gadget view document in the lightbox, must be set while creating the dialog object and executed when the user closes the lightbox with the "close" button
   handleCloseDocument: function () {
      this.commonContainer.then(cre$.util.hitch(this, function(cc) {
          if (this.messageSite.loaded) {
              cc.actions.runAction("com.ibm.socpim.closeDocument");
          } else {
        	  // gadget site is not initialized yet of failed to load.  Either way, just close the lightbox
              this.onMessageClose();
          }
       }));
   },

   verifyExpectedData: function () {
      // Verify it's used as Abstract
      var valid = true;
      var expected = [
                     //fields
                     'idMailListItem', // id mail list item of the header
                     'idCalendarListItem', // id calendar list item of the header
                     'idMailLoadingSpinner', // id mail dropdown of the container (with the loading spinner)
                     'idCalendarLoadingSpinner', // id mail dropdown of the container (with the loading spinner)                      
                     'classBadge', // class of the badge, required as the id is generated dynamically (the badge is already on the page)
                     'classMailDropdown', // class of the mail dropdown, required as it's set during the creation of the gadget site (dropdown div)
                     'classCalendarDropdown', // class of the calendar dropdown, required as it's set during the creation of the gadget site (dropdown div)

                     // methods
                     'generateSuffixToSiteIdsOnHeader', // method which dynamically generates the suffix used for the gadget sites
                     'loadContainerDropdown', // method which loads the container dropdown menu (mail/calendar)
                     'getDropdownContainerId', // method to retrieve the id of the area where we need to display (overlay) the gadget site content. It could be the id of container dropdown menu or of an inner HTML element.
                     'getServiceUrl', // returns the service url
                     'getUrlParameter', // returns the related URL query parameter
                     'initContainer', // initialize and return the Container object
                     'addLoginLogoutHandlers', // add the login and logout handlers
                     'addAttribute', // set/update an attribute of a DOM element, required as we add the dynamically generated id to the badge gadget site
                     'getUserPrefs', // gets user preferences (calendar, textdir, etc.)
                     'generateMessageSite', // generate the DOM structure of the lightbox
                     'generateMessageDialog', // generate the Dialog
                     'calculateBorderWidth', // calculate the border width of the dropdowns
                     'getBadgeSpan', // get the span element where we're going to place the badge gadget site (iframe)
                     'navigateGadgetHandlerCustomProperties', // Custom properties set before the execution of the navigateGadgetHandler
                     'startupSettings', // extra settings during the startup, once the commonContainer object is available in the constructor
                     'onMessageOpen', // callback to "com.ibm.socpim.openDocument" action
                     'onMessageClose', // callback to "com.ibm.socpim.closeDocument.sm" action
                     'onMessageCompose', // callback to "com.ibm.socpim.mail.messageCompose" action
                     'generateGadgetSite', // create the gadget site for the dropdown (mail or calendar)
                     'showSiteContent', // Show <iframe> for gadget
                     'hideInboxWhileLoading', // Hide <iframe> for gadget until bootstrap code in gadget finishes
                     'hideCalendarWhileLoading', // Hide <iframe> for gadget until bootstrap code in gadget finishes
                     'hideLightboxWhileLoading', // Hide <iframe> for gadget until bootstrap code in gadget finishes
                     'setBadgeAccessibilityAttributes', // Add accessibility attributes to the iframe of the badge gadget site
                     'showDialog', // show the message dialog and set accessibility attributes (lightbox)
                     'updateWarning', // JAWS require a removal+addition of the DOM element to inform the user of the alert
                     'extraRpcCalls', // extra RPC calls callbacks which may include container-specific js/DOM references (ie. gadgetSiteObject.onClose)
                     'verifyVisibility', // verify that the gadget site is visible and hide the loading spinner
                     'closeCurrentSite', // close the current gadget site (required by navigateOpenMessage)
                     'isIE', // method which checks if we're using Internet Explorer,
                     'getUserId' // method which returns the user id of the logged in user
                     ];
      var alertMissingData = '';
      for (var index = 0; index < expected.length; index++) {
         var item = expected[index];
         if (!this[item]) {
            alertMissingData += ('- ' + item + '\n');
         }
      }
      if (alertMissingData !== '') {
         alert('Contact your system administrator.\nMissing following fields/methods:\n' + alertMissingData);
         return false;
      }
      return true;
   },
   
   addSuffixToSiteIdsOnHeader: function () {
      var alertMissingDOM = '';
      // checking missing DOM elements
      if (!document.getElementById(this.idMailListItem))
         alertMissingDOM += '\nMissing element with id="' + this.idMailListItem + '"';
      if (!document.getElementById(this.idCalendarListItem))
         alertMissingDOM += '\nMissing element with id="' + this.idCalendarListItem + '"';
      var badgeSpan = this.getBadgeSpan();
      if (!badgeSpan)
         alertMissingDOM += '\nMissing element with class="' + this.classBadge + '"';
      
      if (alertMissingDOM !== '') {
         alert('Contact your system administrator: ' + alertMissingDOM);
         return false;
      }
      // external-content (see MenuLauncher.js)
      this.addAttribute(document.getElementById(this.idMailListItem), "external-content", this.gadgetIDs.inbox);
      this.addAttribute(document.getElementById(this.idCalendarListItem), "external-content", this.gadgetIDs.calendar);
      // id badge
      this.addAttribute(badgeSpan, "id", this.gadgetIDs.badge);
      return true;
   }
   
}
